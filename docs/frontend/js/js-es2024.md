---
title: ES2024
---

# ES2024

## Well-Formed Unicode Strings

### 什么是基本多文种平面（BMP）？

基本多文种平面（Basic Multilingual Plane，BMP）是Unicode字符集中的一个平面，其码点范围是U+0000到U+FFFF。这个平面包含了绝大多数常用的Unicode字符，包括拉丁字母、希腊字母、西里尔字母、阿拉伯数字、中日韩文字等。

### 什么是代理对？

JS 中的字符串是 UTF-16 编码的。在UTF-16编码中，代理对（Surrogate Pair）是一种特殊的编码机制，用于表示那些超出基本多文种平面（BMP）的Unicode字符。这些字符的Unicode码点高于U+FFFF，因此无法用一个16位的UTF-16码元来表示。为了解决这个问题，UTF-16引入了代理对机制。

代理对是由两个16位的码元组成的：
- 一个称为高代理（或高代理码元），其码点范围在U+D800到U+DBFF之间
- 另一个称为低代理（或低代理码元），其码点范围在U+DC00到U+DFFF之间。这两个码元合在一起，可以表示一个超出BMP的Unicode字符。

例如，Unicode码点U+10000（这是BMP之外的第一个码点）在UTF-16中的编码就是高代理码元U+D800和低代理码元U+DC00的组合，即“D800 DC00”。同样，码点U+10001的UTF-16编码就是“D800 DC01”，以此类推。

通过这种方式，UTF-16编码能够完全表示所有Unicode字符，无论是BMP内的还是BMP外的。这种代理对机制是UTF-16编码方案的一个重要组成部分，使得UTF-16成为一种能够灵活处理各种语言字符的编码方式。

### String.prototype.isWellFormed()

`isWellFormed()` 方法用于检查一个字符串是否包含格式良好的 Unicode 代码点序列。如果字符串中的所有代理对都是完整且有效的，则返回 `true`；如果存在孤立的代理码元（即不成对的高代理或低代理码元），则返回 `false`。

#### 示例

```js
// 格式良好的字符串
const wellFormed = "JavaScript";
console.log(wellFormed.isWellFormed()); // true

// 包含表情符号的格式良好字符串（表情符号通常由代理对表示）
const emoji = "😊";
console.log(emoji.isWellFormed()); // true

// 格式不良的字符串（包含孤立的高代理码元）
const highSurrogate = "\uD800";
console.log(highSurrogate.isWellFormed()); // false

// 格式不良的字符串（包含孤立的低代理码元）
const lowSurrogate = "\uDC00";
console.log(lowSurrogate.isWellFormed()); // false

// 格式良好的代理对
const surrogatePair = "\uD83D\uDE0A"; // 等同于 "😊"
console.log(surrogatePair.isWellFormed()); // true

// 格式不良的代理对（代理码元不合法）
const invalidSurrogatePair = "\uD800\u0061"; // 不合法的代理对
console.log(invalidSurrogatePair.isWellFormed()); // false
```

### String.prototype.toWellFormed()

`toWellFormed()` 方法返回一个新的字符串，其中所有孤立的代理码元都被替换为 Unicode 替换字符 U+FFFD (�)。这个方法可以用来修复格式不良的 Unicode 字符串，使其成为格式良好的字符串。

- 如果原字符串已经是格式良好的，则返回与原字符串相同的新字符串
- 如果原字符串包含孤立的代理码元，则返回一个新字符串，其中这些孤立的代理码元被替换为 U+FFFD(�)

#### 示例

```js
// 格式良好的字符串保持不变
const wellFormed = "JavaScript";
console.log(wellFormed.toWellFormed()); // "JavaScript"
console.log(wellFormed.toWellFormed() === wellFormed); // true（内容相同但是新字符串）

// 包含表情符号的格式良好字符串保持不变
const emoji = "😊";
console.log(emoji.toWellFormed()); // "😊"

// 格式不良的字符串（包含孤立的高代理码元）被修复
const highSurrogate = "\uD800";
console.log(highSurrogate.toWellFormed()); // "�"
console.log(highSurrogate.toWellFormed() === "\uFFFD"); // true

// 格式不良的字符串（包含孤立的低代理码元）被修复
const lowSurrogate = "\uDC00";
console.log(lowSurrogate.toWellFormed()); // "�"

// 混合格式的字符串
const mixed = "JavaScript \uD800 is \uDC00 awesome";
console.log(mixed.toWellFormed()); // "JavaScript � is � awesome"

// 与 isWellFormed 结合使用
function safeProcessString(str) {
  if (!str.isWellFormed()) {
    console.warn("字符串格式不良，已自动修复");
    return str.toWellFormed();
  }
  return str;
}

const input = "用户输入: \uD800";
console.log(safeProcessString(input)); // "用户输入: �"（并输出警告）
```

- 可用于数据清理：在处理来自不可信来源的文本数据时，确保字符串格式正确。比如 `encodeURI`在编码一个非高 - 低位完整的代理字符会报错，可以使用 `toWellFormed` 先处理源字符串，就不会报错了。


## Atomics.waitAsync()

`Atomics.waitAsync()` 方法是 `Atomics.wait()` 方法的异步版本。它返回一个 `Promise`，当指定的索引处的元素的值满足给定的条件时，该 `Promise` 会被解析。

> Atomics: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics


## RegExp v flag with set notation + properties of strings

### `v` 标志

`v` 标志是 ES2024 引入的一个新的正则表达式标志，它启用了一些新的特性：

1. 集合表示法
2. 字符串属性转义

### 集合表示法

`v` 标志允许使用更灵活的集合运算符来定义字符类：

- 并集运算：使用 `||` 
- 交集运算：使用 `&&`
- 差集运算：使用 `--`
- 嵌套集合：使用 `[]`

#### 示例

```js
// 并集运算
const vowelRegex = /[aeiou]||[AEIOU]/v;
console.log(vowelRegex.test("Hello")); // true

// 交集运算：匹配既是数字又是偶数的字符
const evenDigitRegex = /[[\d]&&[02468]]/v;
console.log(evenDigitRegex.test("2")); // true
console.log(evenDigitRegex.test("1")); // false

// 差集运算：匹配非数字字符（排除数字）
const nonDigitRegex = /[[\D]--[0-9]]/v;
console.log(nonDigitRegex.test("abc")); // true
console.log(nonDigitRegex.test("123")); // false

// 嵌套集合
const alphanumericRegex = /[a-zA-Z]&&[0-9]||[A-Z]&&[a-z]/v;
console.log(alphanumericRegex.test("a1")); // true
```


### 字符串属性转义

`v` 标志允许在字符类中使用更多字符串属性转义，包括：

- `Basic_Emoji`
- `Emoji_Keycap_Sequence`
- `RGI_Emoji_Modifier_Sequence`
- `RGI_Emoji_Flag_Sequence`
- `RGI_Emoji_Tag_Sequence`
- `RGI_Emoji_ZWJ_Sequence`
- `RGI_Emoji`

#### 示例

```js
const re = /^\p{RGI_Emoji}$/v;

// Match an emoji that consists of just 1 code point:
re.test('⚽'); // '\u26BD'
// → true ✅

// Match an emoji that consists of multiple code points:
re.test('👨🏾‍⚕️'); // '\u{1F468}\u{1F3FE}\u200D\u2695\uFE0F'
// → true ✅
```

### 注意事项

- `v` 标识完全独立于 `u` 标识，二者不能同时使用（否则报错）
- 当i标识被使用时，`u`和`v`标识符的匹配逻辑不同：

> When the `i` flag is set, `\P` character classes are handled slightly differently in `u` and `v` modes. In `u` mode, case-folding happens after subtraction; in `v` mode, case-folding happens before subtraction. More concretely, in `u` mode, `\P{property}` matches `caseFold(allCharacters - charactersWithProperty)`. This means `/\P{Lowercase_Letter}/iu` still matches "a", because A is not a `Lowercase_Letter`. In `v` mode, `\P{property}` matches `caseFold(allCharacters) - caseFold(charactersWithProperty)`. This means `/\P{Lowercase_Letter}/iv` does not match "a", because A is not even in the set of all case-folded Unicode characters.  
> ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Unicode_character_class_escape

### 更多字符串属性转义

todo


## REF
> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI  
> https://v8.dev/features/regexp-v-flag

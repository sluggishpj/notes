---
title: ES2022
---

# ES2022

## Class 相关

### Class Fields

#### 简化变量声明

- before: 声明属性需要在 `constructor()` 内部

```js
class Counter {
  constructor() {
    this.result = 0 // here
  }

  getResult() {
    return this.result
  }
}
```

- after: 可以直接在类定义块内直接声明

```js
class Counter {
  result = 0 // here

  getResult() {
    return this.result
  }
}
```

#### 私有变量和私有方法

通过在变量/方法名前面添加 `#` 让其变为私有

```js
class Counter {
  #step = 1 // here
  result = 0

  setStep = (step) => {
    this.#step = step
    this.#resetResult()
  }

  // here
  #resetResult = () => {
    this.result = 0
  }

  go = () => {
    this.result += this.#step
  }

  getResult = () => this.result
}
```

```js
let c = new Counter()
c.getResult() // 0
c.go()
c.getResult() // 1

c.setStep(2)
c.getResult() // 0
c.go()
c.getResult() // 2

c.#step // Uncaught SyntaxError: Private field '#step' must be declared in an enclosing class

c.#resetResult() // Uncaught SyntaxError: Private field '#resetResult' must be declared in an enclosing class
```

##### 如何判断存在 某私有变量/方法

- before: 使用 `try...catch...`

```js
class C {
  #brand

  static isC(obj) {
    try {
      obj.#brand
      return true
    } catch {
      return false
    }
  }
}
```

- after: 使用 `in`

```js
class C {
  #brand

  #method() {}

  get #getter() {}

  static isC(obj) {
    return #brand in obj && #method in obj && #getter in obj
  }
}
```

> REF: https://github.com/tc39/proposal-private-fields-in-in

#### 公共变量和公共方法

通过[简化变量声明](#简化变量声明) 方式声明的变量，内部调用了 `Object.defineProperty`（又名 `[[Define]]`)。而在 `constructor` 内声明的变量（即 `this.field = val`），实际上是调用了 `[[Set]]`

```js
class A {
  set x(value) {
    console.log(value)
  }
}
class B extends A {
  x = 1
}

const b = new B()
```

> 不会触发 class A 里面的 `set x` 方法

```js
class A {
  set x(value) {
    console.log(value)
  }
}
class C extends A {
  constructor() {
    super()
    this.x = 1
  }
}

const c = new C()
```

> 会触发 class A 里面的 `set x` 方法，即打印 1

#### 类静态变量和静态方法

```js
class FakeMath {
  // `PI` is a static public property.
  static PI = 22 / 7 // Close enough.

  // `#totallyRandomNumber` is a static private property.
  static #totallyRandomNumber = 4

  // `#computeRandomNumber` is a static private method.
  static #computeRandomNumber() {
    return FakeMath.#totallyRandomNumber
  }

  // `random` is a static public method (ES2015 syntax)
  // that consumes `#computeRandomNumber`.
  static random() {
    console.log('I heard you like random numbers…')
    return FakeMath.#computeRandomNumber()
  }
}

FakeMath.PI
// → 3.142857142857143
FakeMath.random()
// logs 'I heard you like random numbers…'
// → 4
FakeMath.#totallyRandomNumber
// → SyntaxError
FakeMath.#computeRandomNumber()
// → SyntaxError
```

#### 简化子类继承

基类

```js
class Animal {
  constructor(name) {
    this.name = name
  }
}
```

- before

```js
class Cat extends Animal {
  constructor(name) {
    super(name)
    this.likesBaths = false
  }
  meow() {
    console.log('Meow!')
  }
}
```

- after

```js
class Cat extends Animal {
  likesBaths = false
  meow() {
    console.log('Meow!')
  }
}
```

### Class Static Block

语法

```js
class C {
  static {
    // statements
  }
}
```

`static`块里面的 this 指向的是 对应的类

```js
class C {
  static {
    console.log(this === C) // true
  }
}
```

因此可以在 `static`块里面直接修改 类静态属性

- before

```js
// without static blocks:
class C {
  static x = 1
  static y
}

C.y = C.x + 2
C.y === 3 // true
```

- after

```js
// with static blocks:
class C {
  static x = 1
  static y
  static {
    C.y = this.x + 2
  }
}

C.y === 3 // true
```

## Top-level `await`

## `.at()`

## Accessible `Object.prototype.hasOwnProperty`

## Error Cause

## REF

> https://github.com/tc39/proposals/blob/master/finished-proposals.md

> https://v8.dev/features/class-fields

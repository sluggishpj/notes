---
title: ES2020
---

## Dynamic `Import()`

### Static `import`

静态 `import` 在 ES2015 就存在了

- `./utils.mjs`

```js
// Default export
export default () => {
  console.log('Hi from the default export!')
}

// Named export `doStuff`
export const doStuff = () => {
  console.log('Doing stuff…')
}
```

静态 `import` 使用如下

```html
<script type="module">
  import * as module from './utils.mjs'
  module.default()
  // → logs 'Hi from the default export!'
  module.doStuff()
  // → logs 'Doing stuff…'
</script>
```

> 后缀 `.mjs` 在浏览器并没有实际意义，因为已经有 `type="module"`，以及通过`Content-Type` 返回 MIME type (`text/javascript`)。 在 `Node.js` 中就有用。

静态 `import` (`import xxx from yyy`) 只能接收 字符串字面值 作为 module specifier。并通过 pre-runtime "linking" 绑定到本地作用域。静态`import` 只能放在文件的最上层。没法做到以下几点：

- import a module on-demand (or conditionally)
- compute the module specifier at runtime
- import a module from within a regular script (as opposed to a module)

### Dynamic Import

`import(moduleSpecifier)` 返回一个 promise。(after fetching, instantiating, and evaluating all of the module’s dependencies, as well as the module itself.)

```html
<script type="module">
  const moduleSpecifier = './utils.mjs'
  import(moduleSpecifier).then(module => {
    module.default()
    // → logs 'Hi from the default export!'
    module.doStuff()
    // → logs 'Doing stuff…'
  })
</script>
```

也可以用 `async/await`

```html
<script type="module">
  ;(async () => {
    const moduleSpecifier = './utils.mjs'
    const module = await import(moduleSpecifier)
    module.default()
    // → logs 'Hi from the default export!'
    module.doStuff()
    // → logs 'Doing stuff…'
  })()
</script>
```

> `import` 不是函数， 也不是 对象。`const importAlias = import`会报错。

## BigInt

## REF

> https://v8.dev/features/tags/es2020

---
title: ES2020
---

## Dynamic `Import()`

### Static `import`

静态 `import` 在 ES2015 就存在了

- `./utils.mjs`

```js
// Default export
export default () => {
  console.log('Hi from the default export!')
}

// Named export `doStuff`
export const doStuff = () => {
  console.log('Doing stuff…')
}
```

静态 `import` 使用如下

```html
<script type="module">
  import * as module from './utils.mjs'
  module.default()
  // → logs 'Hi from the default export!'
  module.doStuff()
  // → logs 'Doing stuff…'
</script>
```

> 后缀 `.mjs` 在浏览器并没有实际意义，因为已经有 `type="module"`，以及通过`Content-Type` 返回 MIME type (`text/javascript`)。 在 `Node.js` 中就有用。

静态 `import` (`import xxx from yyy`) 只能接收 字符串字面值 作为 module specifier。并通过 pre-runtime "linking" 绑定到本地作用域。静态`import` 只能放在文件的最上层。没法做到以下几点：

- import a module on-demand (or conditionally)
- compute the module specifier at runtime
- import a module from within a regular script (as opposed to a module)

### Dynamic Import

`import(moduleSpecifier)` 返回一个 promise。(after fetching, instantiating, and evaluating all of the module’s dependencies, as well as the module itself.)

```html
<script type="module">
  const moduleSpecifier = './utils.mjs'
  import(moduleSpecifier).then(module => {
    module.default()
    // → logs 'Hi from the default export!'
    module.doStuff()
    // → logs 'Doing stuff…'
  })
</script>
```

也可以用 `async/await`

```html
<script type="module">
  ;(async () => {
    const moduleSpecifier = './utils.mjs'
    const module = await import(moduleSpecifier)
    module.default()
    // → logs 'Hi from the default export!'
    module.doStuff()
    // → logs 'Doing stuff…'
  })()
</script>
```

> `import` 不是函数， 也不是 对象。`const importAlias = import`会报错。

## BigInt

`BigInt` 是新的原始数据类型，用来安全地操作超过`Number.MIN_SAFE_INTEGER` ~ `Number.MAX_SAFE_INTEGER` 范围外的整数

```js
typeof 1n // bigint

Number.MAX_SAFE_INTEGER // 9007199254740991，即 2**53 - 1

Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2 // true

9007199254740991n + 1n === 9007199254740991n + 2n // false
```

> 安全存储的意思是指能够准确区分两个不相同的值

### 比较

```js
42 === 42n // false
42n === BigInt(42) // true
42n == 42 // true

123 < 124n // true
```

### 操作符

- 二则运算
  - `+`, `-`, `*`, `**` 正常
  - `/` 和 `%`，结果向 0 取整（丢弃小数部分）
- 二进制运算 `|`, `&`, `<<`, `>>`, `^` 正常

> 不要把 Number 类型和 BigInt 类型 混合运算，会报错

### API

- `BigInt` 构造函数跟 `Number` 构造函数类似: 将参数转换为 `BigInt` ，如果转换失败，则报 `SyntaxError` 或 `RangeError`。

```js
BigInt(123)
// → 123n
BigInt(1.5)
// → RangeError
BigInt('1.5')
// → SyntaxError

BigInt(123456789123456789) // 参数是安全范围外的数字，会发生精度丢失
// → 123456789123456784n ❌
BigInt('123456789123456789') // 参数是整数字符串形式，正常
// → 123456789123456789n ✅
```

- `BigInt.asIntN(width, bigint)`: 将 bigint 对应的值转换为 width 位 有符号整数
- `BigInt.asUintN(width, bigint)`: 将 bigint 对应的值转换为 width 位 无符号整数

```js
// Highest possible BigInt value that can be represented as a
// signed 64-bit integer.
const max = 2n ** (64n - 1n) - 1n
BigInt.asIntN(64, max)
// → 9223372036854775807n
BigInt.asIntN(64, max + 1n)
// → -9223372036854775808n
//   ^ negative because of overflow
```

- `BigInt64Array`: 每一项都是 64 位 有符号整数。`BigUint64Array` 则为对应的 64 位无符号整数

```js
const view = new BigInt64Array(4)
// → [0n, 0n, 0n, 0n]
view.length
// → 4
view[0]
// → 0n
view[0] = 42n
view[0]
// → 42n

// Highest possible BigInt value that can be represented as a
// signed 64-bit integer.
const max = 2n ** (64n - 1n) - 1n
view[0] = max
view[0]
// → 9_223_372_036_854_775_807n
view[0] = max + 1n
view[0]
// → -9_223_372_036_854_775_808n
//   ^ negative because of overflow
```

> MORE: [BigInt64Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array)

## REF

> https://v8.dev/features/tags/es2020

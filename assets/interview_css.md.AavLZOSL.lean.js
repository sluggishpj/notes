import{_ as a,c as n,a2 as t,j as i,a as e,o}from"./chunks/framework.Dr622ulX.js";const E=JSON.parse('{"title":"CSS","description":"","frontmatter":{"title":"CSS"},"headers":[],"relativePath":"interview/css.md","filePath":"docs/interview/css.md"}'),l={name:"interview/css.md"};function d(r,s,h,c,p,k){return o(),n("div",null,s[0]||(s[0]=[t(`<h2 id="选择器优先级" tabindex="-1">选择器优先级 <a class="header-anchor" href="#选择器优先级" aria-label="Permalink to &quot;选择器优先级&quot;">​</a></h2><p><code>!important</code> &gt; 内联 &gt; ID 选择器 &gt; 类选择器 &gt; 元素选择器</p><h2 id="reset-vs-normalize" tabindex="-1">reset vs normalize <a class="header-anchor" href="#reset-vs-normalize" aria-label="Permalink to &quot;reset vs normalize&quot;">​</a></h2><ul><li>reset: 除去所有的浏览器默认样式。对于页面所有的元素，像 <code>margin</code>、<code>padding</code>、<code>font-size</code>这些样式全部置成一样。你将必须重新定义各种元素的样式。</li><li>normalize: 标准化没有去掉所有的默认样式，而是保留了有用的一部分，同时还纠正了一些常见错误。</li></ul><h2 id="清除浮动" tabindex="-1">清除浮动 <a class="header-anchor" href="#清除浮动" aria-label="Permalink to &quot;清除浮动&quot;">​</a></h2><p>有以下 4 个方法：</p><ul><li>父级容器也一块浮动</li><li>父级容器设置 <code>overflow: auto/hidden</code></li><li>添加伪元素 <code>clear:both</code></li></ul><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.clearfix::before</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.clearfix::after</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39; &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">table</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.clearfix::after</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  clear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">both</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.clearfix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  zoom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* For IE 6/7 (trigger hasLayout) */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>父容器设置 <code>display: flow-root</code></li></ul>`,9),i("iframe",{height:"300",style:{width:"100%"},scrolling:"no",title:"css-clear-fix",src:"https://codepen.io/rinxu/embed/gOxZKoM?default-tab=css%2Cresult",frameborder:"no",loading:"lazy",allowtransparency:"true",allowfullscreen:"true"},[e(" See the Pen "),i("a",{href:"https://codepen.io/rinxu/pen/gOxZKoM"}," css-clear-fix"),e(" by Rin ("),i("a",{href:"https://codepen.io/rinxu"},"@rinxu"),e(") on "),i("a",{href:"https://codepen.io"},"CodePen"),e(". ")],-1),t('<h2 id="z-index-如何形成层叠上下文-stacking-context" tabindex="-1"><code>z-index</code> 如何形成层叠上下文(stacking context) <a class="header-anchor" href="#z-index-如何形成层叠上下文-stacking-context" aria-label="Permalink to &quot;`z-index` 如何形成层叠上下文(stacking context)&quot;">​</a></h2><ul><li><code>z-index</code> 只能影响<code>position</code>值不是<code>static</code>的元素</li></ul><p>没有定义<code>z-index</code>的值时，元素按照它们出现在 DOM 中的顺序堆叠（层级越低，出现位置越靠上）。非静态定位的元素（及其子元素）将始终覆盖静态定位（static）的元素，而不管 HTML 层次结构如何。</p><p>层叠上下文是包含一组图层的元素。 在一组层叠上下文中，其子元素的<code>z-index</code>值是相对于其<strong>父元素</strong>而不是 document root 设置的。每个层叠上下文完全独立于它的兄弟元素。如果元素 B 位于元素 A 之上，则即使元素 A 的子元素 C 具有比元素 B 更高的<code>z-index</code>值，元素 C 也永远不会在元素 B 之上.</p><p>每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会在父层叠上下文中按顺序进行层叠。少数 CSS 属性会触发一个新的层叠上下文，例如 <code>opacity</code> 小于 1，<code>filter</code> 不是 none，<code>transform</code> 不是 none。</p><h2 id="格式化上下文-bfc-block-formatting-context-及其工作原理" tabindex="-1">格式化上下文（BFC, Block Formatting Context）及其工作原理 <a class="header-anchor" href="#格式化上下文-bfc-block-formatting-context-及其工作原理" aria-label="Permalink to &quot;格式化上下文（BFC, Block Formatting Context）及其工作原理&quot;">​</a></h2><p>块格式化上下文（Block Formatting Context，BFC） 是 Web 页面的可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p><p>一个 HTML 盒（Box）满足以下任意一条，会创建块格式化上下文：</p><ul><li><code>float</code> 的值不是 <code>none</code>.</li><li><code>position</code> 的值不是 <code>static</code> 或 <code>relative</code>.</li><li><code>display</code> 的值是 <code>table-cell</code>、<code>table-caption</code>、<code>inline-block</code>、<code>flex</code>、或 <code>inline-flex</code>、或 <code>grid</code>、<code>inline-grid</code> 或 <strong><code>flow-root</code></strong>。</li><li><code>overflow</code> 的值不是 <code>visible</code>。</li></ul><p>应用：</p><ul><li>浮动定位和清除浮动时只会应用于同一个 BFC 内的元素。浮动不会影响其它 BFC 中元素的布局，而清除浮动只能清除同一 BFC 中在它前面的元素的浮动。</li><li>外边距折叠（Margin collapsing）也只会发生在属于同一 BFC 的块级元素之间。</li></ul>',11),i("iframe",{height:"300",style:{width:"100%"},scrolling:"no",title:"Untitled",src:"https://codepen.io/rinxu/embed/WNEVOZQ?default-tab=css%2Cresult",frameborder:"no",loading:"lazy",allowtransparency:"true",allowfullscreen:"true"},[e(" See the Pen "),i("a",{href:"https://codepen.io/rinxu/pen/WNEVOZQ"}," Untitled"),e(" by Rin ("),i("a",{href:"https://codepen.io/rinxu"},"@rinxu"),e(") on "),i("a",{href:"https://codepen.io"},"CodePen"),e(". ")],-1),t('<blockquote><p>看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context#specifications" target="_blank" rel="noreferrer">示例</a> 更好理解。个人理解：一个 BFC 会把自己的孩子包裹住，不管孩子是否浮动。</p></blockquote><h2 id="有什么不同的方式可以隐藏内容-使其仅适用于屏幕阅读器" tabindex="-1">有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器） <a class="header-anchor" href="#有什么不同的方式可以隐藏内容-使其仅适用于屏幕阅读器" aria-label="Permalink to &quot;有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）&quot;">​</a></h2><p>这些方法与可访问性（a11y）有关。</p><ul><li><code>width: 0; height: 0</code>：使元素不占用屏幕上的任何空间，导致不显示它。</li><li><code>position: absolute; left: -99999px</code>： 将它置于屏幕之外。</li><li><code>text-indent: -9999px</code>：这只适用于 block 元素中的文本。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA" target="_blank" rel="noreferrer">WAI-ARIA</a>：如何增加网页可访问性的 W3C 技术规范。</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;percent-loaded&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> role</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;progressbar&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> aria-valuenow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;75&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> aria-valuemin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;0&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> aria-valuemax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;100&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="编写高效-css" tabindex="-1">编写高效 CSS <a class="header-anchor" href="#编写高效-css" aria-label="Permalink to &quot;编写高效 CSS&quot;">​</a></h2><p>首先，浏览器<strong>从最右边</strong>的选择器，即关键选择器（key selector），<strong>向左</strong>依次匹配。根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。避免使用标签和通用选择器作为关键选择器，因为它们会匹配大量的元素，浏览器必须要进行大量的工作，去判断这些元素的父元素们是否匹配。</p><p>BEM (Block Element Modifier)原则上建议为独立的 CSS 类命名，并且在需要层级关系时，将关系也体现在命名中，这自然会使选择器高效且易于覆盖。eg. <code>.el-radio__input--small</code></p><p>搞清楚哪些 CSS 属性会触发重新布局（reflow）、重绘（repaint）和合成（compositing）。在写样式时，避免触发重新布局的可能。</p><h2 id="描述伪元素及其用途" tabindex="-1">描述伪元素及其用途 <a class="header-anchor" href="#描述伪元素及其用途" aria-label="Permalink to &quot;描述伪元素及其用途&quot;">​</a></h2><p>CSS 伪元素是添加到<strong>选择器</strong>的关键字，去<strong>选择元素的特定部分</strong>。它们可以用于装饰（<code>:first-line</code>，<code>:first-letter</code>）或将元素添加到标记中（与 <code>content:...</code>组合），而不必修改标记（<code>:before</code>，<code>:after</code>）。</p><h2 id="block-vs-inline-block-vs-inline" tabindex="-1">block vs inline-block vs inline <a class="header-anchor" href="#block-vs-inline-block-vs-inline" aria-label="Permalink to &quot;block vs inline-block vs inline&quot;">​</a></h2><table tabindex="0"><thead><tr><th></th><th><code>block</code></th><th><code>inline-block</code></th><th><code>inline</code></th></tr></thead><tbody><tr><td>大小</td><td>填充其父容器的宽度。</td><td>取决于内容。</td><td>取决于内容。</td></tr><tr><td>定位</td><td>从新的一行开始，并且不允许旁边有 HTML 元素（除非是<code>float</code>）</td><td>与其他内容一起流动，并允许旁边有其他元素。</td><td>与其他内容一起流动，并允许旁边有其他元素。</td></tr><tr><td>能否设置<code>width</code>和<code>height</code></td><td>能</td><td>能</td><td>不能。 设置会被忽略。</td></tr><tr><td>可以使用<code>vertical-align</code>对齐</td><td>不可以</td><td>可以</td><td>可以</td></tr><tr><td>边距（margin）和填充（padding）</td><td>各个方向都存在</td><td>各个方向都存在</td><td><strong>只有水平方向</strong>存在。垂直方向会被忽略。 尽管<code>border</code>和<code>padding</code>在<code>content</code>周围，但垂直方向上的空间取决于<code>line-height</code></td></tr><tr><td>浮动（float）</td><td>-</td><td>-</td><td>就像一个<code>block</code>元素，可以设置垂直边距和填充。</td></tr></tbody></table><h2 id="position各个值区别" tabindex="-1"><code>position</code>各个值区别 <a class="header-anchor" href="#position各个值区别" aria-label="Permalink to &quot;`position`各个值区别&quot;">​</a></h2><h2 id="ref" tabindex="-1">REF <a class="header-anchor" href="#ref" aria-label="Permalink to &quot;REF&quot;">​</a></h2><blockquote><p><a href="https://github.com/yangshun/front-end-interview-handbook" target="_blank" rel="noreferrer">https://github.com/yangshun/front-end-interview-handbook</a></p></blockquote>',16)]))}const u=a(l,[["render",d]]);export{E as __pageData,u as default};

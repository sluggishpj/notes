import{_ as l,c as n,a2 as e,j as i,a as s,o as t}from"./chunks/framework.Dr622ulX.js";const g=JSON.parse('{"title":"盒子模型","description":"","frontmatter":{"title":"盒子模型"},"headers":[],"relativePath":"frontend/css/css-box-model.md","filePath":"docs/frontend/css/css-box-model.md"}'),o={name:"frontend/css/css-box-model.md"};function h(r,a,d,p,k,c){return t(),n("div",null,a[0]||(a[0]=[e('<h1 id="盒子模型" tabindex="-1">盒子模型 <a class="header-anchor" href="#盒子模型" aria-label="Permalink to &quot;盒子模型&quot;">​</a></h1><h2 id="block-inline-inline-block" tabindex="-1">block, inline, inline-block <a class="header-anchor" href="#block-inline-inline-block" aria-label="Permalink to &quot;block, inline, inline-block&quot;">​</a></h2><h3 id="块级-block" tabindex="-1">块级 block <a class="header-anchor" href="#块级-block" aria-label="Permalink to &quot;块级 block&quot;">​</a></h3><ul><li>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽</li><li>每个盒子都会换行</li><li><code>width</code> 和 <code>height</code> 属性可以发挥作用</li><li>内边距（padding）, 外边距（margin） 和 边框（border） 会将其他元素从当前盒子周围“推开”</li></ul><h3 id="行内-inline" tabindex="-1">行内 inline <a class="header-anchor" href="#行内-inline" aria-label="Permalink to &quot;行内 inline&quot;">​</a></h3><ul><li>盒子不会产生换行</li><li><code>width</code> 和 <code>height</code> 属性将不起作用</li><li><strong>垂直</strong>方向的内边距、外边距以及边框会被应用但是<strong>不会</strong>把其他处于 <code>inline</code> 状态的盒子推开</li><li><strong>水平</strong>方向的内边距、外边距以及边框会被应用且<strong>会</strong>把其他处于 <code>inline</code> 状态的盒子推开</li></ul><h3 id="行内块级-inline-block" tabindex="-1">行内块级 inline-block <a class="header-anchor" href="#行内块级-inline-block" aria-label="Permalink to &quot;行内块级 inline-block&quot;">​</a></h3><ul><li>设置 <code>width</code> 和 <code>height</code> 属性会生效</li><li><code>padding</code>, <code>margin</code>, 以及 <code>border</code> 会推开其他元素</li><li>不会产生换行</li></ul>',8),i("iframe",{height:"300",style:{width:"100%"},scrolling:"no",title:"box-model:inline and block",src:"https://codepen.io/rinxu/embed/GRmQbxB?default-tab=css%2Cresult",frameborder:"no",loading:"lazy",allowtransparency:"true",allowfullscreen:"true"},[s(" See the Pen "),i("a",{href:"https://codepen.io/rinxu/pen/GRmQbxB"}," box-model:inline and block"),s(" by Rin ("),i("a",{href:"https://codepen.io/rinxu"},"@rinxu"),s(") on "),i("a",{href:"https://codepen.io"},"CodePen"),s(". ")],-1),e(`<h2 id="补充-内部和外部显示类型" tabindex="-1">补充: 内部和外部显示类型 <a class="header-anchor" href="#补充-内部和外部显示类型" aria-label="Permalink to &quot;补充: 内部和外部显示类型&quot;">​</a></h2><p>css 的 box 模型有一个外部显示类型，来决定盒子是块级还是内联。</p><p>同样盒模型还有内部显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照 正常文档流 布局，也意味着它们和其他块元素以及内联元素一样</p><p>可以通过<code>display</code> 属性值来更改内部显示类型。 如果设置 <code>display: flex</code>，在一个元素上，外部显示类型是 block，但是内部显示类型修改为 flex。</p><h2 id="css-盒模型" tabindex="-1">CSS 盒模型 <a class="header-anchor" href="#css-盒模型" aria-label="Permalink to &quot;CSS 盒模型&quot;">​</a></h2><p><img src="https://mdn.mozillademos.org/files/16558/box-model.png" alt=""></p><h3 id="box-sizing" tabindex="-1">box-sizing <a class="header-anchor" href="#box-sizing" aria-label="Permalink to &quot;box-sizing&quot;">​</a></h3><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">350</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">150</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  margin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  padding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  border</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> solid</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> black</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="标准盒模型-content-box" tabindex="-1">标准盒模型 content-box <a class="header-anchor" href="#标准盒模型-content-box" aria-label="Permalink to &quot;标准盒模型 content-box&quot;">​</a></h4><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  box-sizing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">content-box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><img src="https://mdn.mozillademos.org/files/16559/standard-box-model.png" alt="content-box"></p><h4 id="ie-盒模型-border-box" tabindex="-1">IE 盒模型 border-box <a class="header-anchor" href="#ie-盒模型-border-box" aria-label="Permalink to &quot;IE 盒模型 border-box&quot;">​</a></h4><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  box-sizing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">border-box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><img src="https://mdn.mozillademos.org/files/16557/alternate-box-model.png" alt="border-box"></p><h2 id="外边距-内边距-边框" tabindex="-1">外边距，内边距，边框 <a class="header-anchor" href="#外边距-内边距-边框" aria-label="Permalink to &quot;外边距，内边距，边框&quot;">​</a></h2><h3 id="外边距" tabindex="-1">外边距 <a class="header-anchor" href="#外边距" aria-label="Permalink to &quot;外边距&quot;">​</a></h3><h4 id="外边距折叠" tabindex="-1">外边距折叠 <a class="header-anchor" href="#外边距折叠" aria-label="Permalink to &quot;外边距折叠&quot;">​</a></h4><p>现象：两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小。</p><blockquote><p>有设定 <code>float</code> 和 <code>position:absolute</code> 的元素不会产生外边距重叠行为。</p></blockquote><p>以下 3 种情况会造成外边距折叠：</p><ul><li>同一层相邻元素之间：相邻的两个元素之间的外边距重叠，除非后一个元素加上 clear-fix 清除浮动。</li><li>没有内容将父元素和后代元素分开</li><li>空的块级元素</li></ul><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="noreferrer">外边距折叠 | MDN</a></p></blockquote><h2 id="ref" tabindex="-1">REF <a class="header-anchor" href="#ref" aria-label="Permalink to &quot;REF&quot;">​</a></h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model</a></p></blockquote>`,24)]))}const E=l(o,[["render",h]]);export{g as __pageData,E as default};

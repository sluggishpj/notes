import{_ as i,c as a,a2 as e,o as t}from"./chunks/framework.Dr622ulX.js";const k=JSON.parse('{"title":"定位","description":"","frontmatter":{"title":"定位"},"headers":[],"relativePath":"frontend/css/css-positioning.md","filePath":"docs/frontend/css/css-positioning.md"}'),n={name:"frontend/css/css-positioning.md"};function o(l,s,p,c,d,h){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="定位" tabindex="-1">定位 <a class="header-anchor" href="#定位" aria-label="Permalink to &quot;定位&quot;">​</a></h1><h2 id="定位-position" tabindex="-1">定位 position <a class="header-anchor" href="#定位-position" aria-label="Permalink to &quot;定位 position&quot;">​</a></h2><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">position: static;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">position: relative;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">position: absolute;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">position: fixed;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">position: sticky;</span></span></code></pre></div><h3 id="粘性定位-sticky" tabindex="-1">粘性定位 sticky <a class="header-anchor" href="#粘性定位-sticky" aria-label="Permalink to &quot;粘性定位 sticky&quot;">​</a></h3><p>元素根据正常文档流进行定位，然后相对它的最近滚动祖先（nearest scrolling ancestor）和 containing block (最近块级祖先 nearest block-level ancestor)，包括 table-related 元素，基于 top, right, bottom, 和 left 的值进行偏移。偏移值不会影响任何其他元素的位置。</p><p>粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。</p><h2 id="z-index" tabindex="-1">z-index <a class="header-anchor" href="#z-index" aria-label="Permalink to &quot;z-index&quot;">​</a></h2><p>对于一个已经定位的盒子（即其 <code>position</code> 属性值不是 <code>static</code>，这里要注意的是 CSS 把元素看作盒子），<code>z-index</code> 属性指定：</p><ul><li>盒子在当前堆叠上下文中的堆叠层级</li><li>盒子是否创建一个本地堆叠上下文</li></ul><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">z-index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: auto;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">z-index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: &lt;integer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p><code>&lt;integer&gt;</code>（整型数字）是生成的盒子在当前堆叠上下文中的堆叠层级。此盒子也会创建一个堆叠层级为 0 的本地堆叠上下文。这意味着后代（元素）的 <code>z-indexes</code> 不与此元素的外部元素的 <code>z-indexes</code> 进行对比。</p>`,11)]))}const g=i(n,[["render",o]]);export{k as __pageData,g as default};
